"use server";

import { FlowniRole } from "@repo/backend/auth";
import { currentOrganizationId, currentUser } from "@repo/backend/auth/utils";
import { tables } from "@repo/backend/database";
import type { Changelog } from "@repo/backend/types";
import {
  contentToText,
  markdownToContent,
  textToContent,
} from "@repo/editor/lib/tiptap";
import { parseError } from "@repo/lib/parse-error";
import { generateText } from "ai";
import { and, desc, eq, gte } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { database } from "@/lib/database";

export const generateChangelog = async (
  changelogId: Changelog["id"],
  withAi: boolean
): Promise<{
  error?: string;
}> => {
  try {
    const [user, organizationId] = await Promise.all([
      currentUser(),
      currentOrganizationId(),
    ]);

    if (!(user && organizationId)) {
      throw new Error("Not logged in");
    }

    if (user.organizationRole === FlowniRole.Member) {
      throw new Error(
        "You do not have permission to generate changelog updates"
      );
    }

    if (!withAi) {
      await database
        .update(tables.changelog)
        .set({
          content: textToContent(""),
          updatedAt: new Date().toISOString(),
        })
        .where(eq(tables.changelog.id, changelogId));

      revalidatePath(`/changelog/${changelogId}`);

      return {};
    }

    const organization = await database
      .select()
      .from(tables.organization)
      .where(eq(tables.organization.id, organizationId))
      .limit(1)
      .then((rows) => rows[0] ?? null);

    if (!organization) {
      throw new Error("Organization not found");
    }

    const lastChangelog = await database
      .select()
      .from(tables.changelog)
      .where(eq(tables.changelog.organizationId, organizationId))
      .orderBy(desc(tables.changelog.createdAt))
      .limit(1)
      .then((rows) => rows[0] ?? null);

    let content: object = textToContent("");

    if (lastChangelog) {
      const newlyCompletedFeatures = await database
        .select({
          id: tables.feature.id,
          title: tables.feature.title,
          content: tables.feature.content,
        })
        .from(tables.feature)
        .innerJoin(
          tables.featureStatus,
          eq(tables.featureStatus.id, tables.feature.statusId)
        )
        .where(
          and(
            eq(tables.feature.organizationId, organizationId),
            eq(tables.featureStatus.complete, true),
            gte(tables.feature.endAt, lastChangelog.publishAt)
          )
        );

      if (newlyCompletedFeatures.length > 0) {
        const features = newlyCompletedFeatures.map((feature) => {
          const text = feature.content
            ? contentToText(feature.content)
            : "No description provided.";

          return `- ${feature.title}: ${text}`.trim();
        });

        const markdown = await generateText({
          model: "openai/gpt-5-nano",
          system: [
            "You are an AI that takes a list of features that have been completed since the last update and potentially a product description.",
            "Your job is to generate a public-facing product update for a changelog that will be shared with the organization's customers.",
            "Do not give the update a title, as it will be generated by the user.",
            "Format your response in Markdown.",
          ].join("\n"),
          prompt: [
            "Here are the features that have been completed since the last update:",
            ...features,
            "------",
            "Here is a brief description of the product:",
            organization.productDescription ?? "None provided.",
          ].join("\n"),
        });

        content = await markdownToContent(markdown.text);
      }
    }

    await database
      .update(tables.changelog)
      .set({ content, updatedAt: new Date().toISOString() })
      .where(eq(tables.changelog.id, changelogId));

    revalidatePath(`/changelog/${changelogId}`);

    return {};
  } catch (error) {
    const message = parseError(error);

    return { error: message };
  }
};
